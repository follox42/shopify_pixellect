class LightRay {
    constructor(canvasId, options = {}) {
        // Get canvas reference
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        // Default parameters
        this.options = {
            pixelSize: options.pixelSize || 8,            // Pixel size
            angle: options.angle || 45,                   // Opening angle of the ray in degrees
            direction: options.direction || 270,          // Direction of the ray in degrees (0 = right, 90 = down, etc.)
            intensity: options.intensity || 1.0,          // Light intensity
            centerColor: options.centerColor || '#ffffff',  // Color at the center of the ray
            midColor: options.midColor || '#f5d76e',      // Intermediate color
            edgeColor: options.edgeColor || '#996633',    // Color at the edges of the ray
            edgeAlpha: options.edgeAlpha || 0.7,          // Alpha for the edge color (transparency)
            edgeSharpness: options.edgeSharpness || 0.8,  // Edge sharpness (0 = blurry, 1 = sharp)
            noise: options.noise || 0.2,                  // Noise level (0 = none, 1 = high)
            density: options.density || 0.7,              // Light density (length)
            brightness: options.brightness || 1.3,        // Brightness (light contrast)
            spread: options.spread || 0.6,                // Color spread
            lightPoints: options.lightPoints || [],       // Random light points
            minAlpha: options.minAlpha || 0.05           // Minimum alpha threshold for rendering
        };

        // Initialization
        this.resizeCanvas();
        this.generateNoise();
        this.render();

        // Auto-resize
        window.addEventListener('resize', () => {
            this.resizeCanvas();
            this.render();
        });
    }

    // Resize canvas
    resizeCanvas() {
        const parent = this.canvas.parentElement;
        this.canvas.width = parent.clientWidth;
        this.canvas.height = parent.clientHeight;
        this.pixelsX = Math.ceil(this.canvas.width / this.options.pixelSize);
        this.pixelsY = Math.ceil(this.canvas.height / this.options.pixelSize);
    }

    // Generate noise map for organic effect
    generateNoise() {
        this.noiseMap = [];
        for (let y = 0; y < this.pixelsY; y++) {
            this.noiseMap[y] = [];
            for (let x = 0; x < this.pixelsX; x++) {
                this.noiseMap[y][x] = Math.random();
            }
        }
    }

    // Get noise value at a given position
    getNoise(x, y) {
        return this.noiseMap[Math.floor(y) % this.noiseMap.length][Math.floor(x) % this.noiseMap[0].length];
    }

    // Check if a point is in the light ray
    isInRay(x, y) {
        // Normalized coordinates (0-1)
        const nx = x / this.pixelsX;
        const ny = y / this.pixelsY;

        // Canvas center
        const cx = 0.5;
        const cy = 0.5;

        // Ray direction in radians (adjusted so 0° points upwards)
        const dirRad = (this.options.direction - 90) * Math.PI / 180;

        // Position adjusted by direction
        const dx = nx - cx;
        const dy = ny - cy;

        // Distance from center
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Angle relative to ray direction (in radians)
        const pointAngle = Math.atan2(dy, dx);

        // Angle difference (adjusted to be between -π and π)
        let angleDiff = pointAngle - dirRad;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        // Half opening angle in radians
        const halfAngle = (this.options.angle / 2) * Math.PI / 180;

        // Is the point in the ray?
        const inAngle = Math.abs(angleDiff) <= halfAngle;

        // Calculate intensity based on distance from center and angle
        let intensity = 0;
        if (inAngle) {
            // Factor based on distance from center
            const distanceFactor = Math.max(0, 1 - (distance / this.options.density));

            // Factor based on deviation from ray's central axis
            const angleFactor = Math.pow(1 - Math.abs(angleDiff) / halfAngle, this.options.edgeSharpness);

            // Final intensity (combination of both factors)
            intensity = distanceFactor * angleFactor * this.options.intensity;

            // Add noise to make edges more organic
            if (this.options.noise > 0) {
                const noise = (this.getNoise(x * 3, y * 3) - 0.5) * this.options.noise;
                intensity = Math.max(0, Math.min(1, intensity + noise));
            }

            // Adjustment with brightness parameter
            intensity = Math.pow(intensity, 1 / this.options.brightness);
        }

        return intensity;
    }

    // Hex to RGBA color conversion
    hexToRgba(hex, alpha = 1) {
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Blend two colors based on a ratio with transparency
    getColorWithAlpha(intensity) {
        const { centerColor, midColor, edgeColor, edgeAlpha, spread } = this.options;

        // No light = fully transparent
        if (intensity <= 0) return 'rgba(0, 0, 0, 0)';

        // Adjust thresholds based on spread parameter
        const midThreshold = 0.5 * spread;
        const edgeThreshold = 0.2 * spread;

        // Calculate alpha based on intensity
        let alpha;
        let color;

        if (intensity > midThreshold) {
            // Between mid and center
            const ratio = (intensity - midThreshold) / (1 - midThreshold);
            color = midColor;
            if (ratio > 0.7) {
                color = centerColor;
            }
            alpha = 0.7 + (ratio * 0.3); // 0.7 to 1.0
        } else if (intensity > edgeThreshold) {
            // Between edge and mid
            const ratio = (intensity - edgeThreshold) / (midThreshold - edgeThreshold);
            color = edgeColor;
            if (ratio > 0.5) {
                color = midColor;
            }
            alpha = 0.3 + (ratio * 0.4); // 0.3 to 0.7
        } else {
            // Between transparent and edge
            const ratio = intensity / edgeThreshold;
            color = edgeColor;
            alpha = edgeAlpha * ratio; // 0 to edgeAlpha
        }

        // Convert to RGBA
        return this.hexToRgba(color, alpha);
    }

    // Render the pixelated light effect
    render() {
        const { pixelSize, minAlpha } = this.options;

        // Clear canvas (make it transparent)
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw each pixel
        for (let y = 0; y < this.pixelsY; y++) {
            for (let x = 0; x < this.pixelsX; x++) {
                // Calculate light intensity at this position
                let intensity = this.isInRay(x, y);

                // Add random light points
                for (const point of this.options.lightPoints) {
                    const dx = x - point.x * this.pixelsX;
                    const dy = y - point.y * this.pixelsY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const pointIntensity = Math.max(0, 1 - (distance / (point.radius * this.pixelsX / 100)));
                    intensity = Math.max(intensity, pointIntensity * point.intensity);
                }

                // If the position receives enough light, draw the pixel
                if (intensity > minAlpha) {
                    this.ctx.fillStyle = this.getColorWithAlpha(intensity);
                    this.ctx.fillRect(
                        x * pixelSize,
                        y * pixelSize,
                        pixelSize,
                        pixelSize
                    );
                }
            }
        }
    }

    // Update options
    updateOptions(newOptions) {
        // Update options
        this.options = { ...this.options, ...newOptions };

        // If pixel size changes, resize
        if (newOptions.pixelSize) {
            this.resizeCanvas();
        }

        // If noise level changes, regenerate noise map
        if (newOptions.noise !== undefined) {
            this.generateNoise();
        }

        // Update light points if needed
        if (newOptions.lightPoints) {
            this.options.lightPoints = [...newOptions.lightPoints];
        }

        // Render again
        this.render();
    }

    // Add a random light point
    addLightPoint(x, y, radius = 10, intensity = 1) {
        const point = { x, y, radius, intensity };
        this.options.lightPoints.push(point);
        this.render();
        return point;
    }

    // Remove a light point
    removeLightPoint(index) {
        if (index >= 0 && index < this.options.lightPoints.length) {
            this.options.lightPoints.splice(index, 1);
            this.render();
        }
    }
}

// Create UI controls
function createInterface(containerId, lightRay) {
    const container = document.getElementById(containerId);

    // Presets section
    const presetsSection = document.createElement("div");
    presetsSection.className = "control-section";

    const presetsTitle = document.createElement("h3");
    presetsTitle.textContent = "PRESETS";
    presetsSection.appendChild(presetsTitle);

    const presets = [
        {
            name: "Vertical Ray",
            options: {
                angle: 40,
                direction: 270,
                centerColor: "#ffffff",
                midColor: "#f5d76e",
                edgeColor: "#996633",
                edgeAlpha: 0.7,
                edgeSharpness: 0.8,
                noise: 0.15,
                density: 0.7,
                brightness: 1.3
            }
        },
        {
            name: "Divine Light",
            options: {
                angle: 60,
                direction: 270,
                centerColor: "#ffffff",
                midColor: "#fffacd",
                edgeColor: "#d4af37",
                edgeAlpha: 0.8,
                edgeSharpness: 0.9,
                noise: 0.1,
                density: 0.8,
                brightness: 1.5,
                intensity: 1.3
            }
        },
        {
            name: "Laser Beam",
            options: {
                angle: 10,
                direction: 0,
                centerColor: "#ff3333",
                midColor: "#ff6666",
                edgeColor: "#990000",
                edgeAlpha: 0.6,
                edgeSharpness: 2,
                noise: 0.05,
                density: 1.2,
                brightness: 1.8
            }
        },
        {
            name: "UV Light",
            options: {
                angle: 120,
                direction: 220,
                centerColor: "#cc00ff",
                midColor: "#9900cc",
                edgeColor: "#660099",
                edgeAlpha: 0.7,
                edgeSharpness: 0.7,
                noise: 0.2,
                density: 0.6,
                brightness: 1.2
            }
        },
        {
            name: "Full Circle",
            options: {
                angle: 360,
                centerColor: "#66ffff",
                midColor: "#0099cc",
                edgeColor: "#003366",
                edgeAlpha: 0.8,
                edgeSharpness: 1.0,
                noise: 0.2,
                density: 0.5,
                brightness: 1.1
            }
        }
    ];

    const presetsContainer = document.createElement("div");
    presetsContainer.className = "presets-container";

    presets.forEach(preset => {
        const button = document.createElement("button");
        button.className = "preset-button";
        button.textContent = preset.name;
        button.addEventListener("click", () => {
            lightRay.updateOptions(preset.options);
            updateControlValues(preset.options);
        });
        presetsContainer.appendChild(button);
    });

    presetsSection.appendChild(presetsContainer);
    container.appendChild(presetsSection);

    // Ray Shape section
    createSection("Ray Shape", [
        {
            type: "range",
            id: "pixelSize",
            label: "Pixel Size",
            min: 2,
            max: 20,
            step: 1,
            value: lightRay.options.pixelSize,
            onChange: (val) => lightRay.updateOptions({ pixelSize: parseInt(val) })
        },
        {
            type: "range",
            id: "angle",
            label: "Opening Angle",
            min: 1,
            max: 360,
            step: 1,
            value: lightRay.options.angle,
            onChange: (val) => lightRay.updateOptions({ angle: parseInt(val) })
        },
        {
            type: "range",
            id: "direction",
            label: "Direction",
            min: 0,
            max: 360,
            step: 1,
            value: lightRay.options.direction,
            onChange: (val) => lightRay.updateOptions({ direction: parseInt(val) })
        },
        {
            type: "range",
            id: "edgeSharpness",
            label: "Edge Sharpness",
            min: 0.1,
            max: 3,
            step: 0.1,
            value: lightRay.options.edgeSharpness,
            onChange: (val) => lightRay.updateOptions({ edgeSharpness: parseFloat(val) })
        },
        {
            type: "range",
            id: "noise",
            label: "Organic Effect (Noise)",
            min: 0,
            max: 0.5,
            step: 0.01,
            value: lightRay.options.noise,
            onChange: (val) => lightRay.updateOptions({ noise: parseFloat(val) })
        }
    ], container);

    // Light Properties section
    createSection("Light Properties", [
        {
            type: "range",
            id: "intensity",
            label: "Intensity",
            min: 0.1,
            max: 2,
            step: 0.1,
            value: lightRay.options.intensity,
            onChange: (val) => lightRay.updateOptions({ intensity: parseFloat(val) })
        },
        {
            type: "range",
            id: "density",
            label: "Density (Length)",
            min: 0.1,
            max: 2,
            step: 0.1,
            value: lightRay.options.density,
            onChange: (val) => lightRay.updateOptions({ density: parseFloat(val) })
        },
        {
            type: "range",
            id: "brightness",
            label: "Brightness",
            min: 0.5,
            max: 3,
            step: 0.1,
            value: lightRay.options.brightness,
            onChange: (val) => lightRay.updateOptions({ brightness: parseFloat(val) })
        },
        {
            type: "range",
            id: "spread",
            label: "Color Spread",
            min: 0.2,
            max: 2,
            step: 0.1,
            value: lightRay.options.spread,
            onChange: (val) => lightRay.updateOptions({ spread: parseFloat(val) })
        },
        {
            type: "range",
            id: "edgeAlpha",
            label: "Edge Transparency",
            min: 0.1,
            max: 1,
            step: 0.05,
            value: lightRay.options.edgeAlpha,
            onChange: (val) => lightRay.updateOptions({ edgeAlpha: parseFloat(val) })
        },
        {
            type: "range",
            id: "minAlpha",
            label: "Minimum Opacity",
            min: 0.01,
            max: 0.2,
            step: 0.01,
            value: lightRay.options.minAlpha,
            onChange: (val) => lightRay.updateOptions({ minAlpha: parseFloat(val) })
        }
    ], container);

    // Colors section
    createSection("Colors", [
        {
            type: "color",
            id: "centerColor",
            label: "Center Color",
            value: lightRay.options.centerColor,
            onChange: (val) => lightRay.updateOptions({ centerColor: val })
        },
        {
            type: "color",
            id: "midColor",
            label: "Mid Color",
            value: lightRay.options.midColor,
            onChange: (val) => lightRay.updateOptions({ midColor: val })
        },
        {
            type: "color",
            id: "edgeColor",
            label: "Edge Color",
            value: lightRay.options.edgeColor,
            onChange: (val) => lightRay.updateOptions({ edgeColor: val })
        }
    ], container);

    // Light Points section
    const pointsSection = document.createElement("div");
    pointsSection.className = "control-section";

    const pointsTitle = document.createElement("h3");
    pointsTitle.textContent = "LIGHT POINTS";
    pointsSection.appendChild(pointsTitle);

    const pointsInfo = document.createElement("p");
    pointsInfo.textContent = "Click on the canvas to add light points";
    pointsInfo.style.marginBottom = "10px";
    pointsSection.appendChild(pointsInfo);

    const pointsList = document.createElement("div");
    pointsList.id = "points-list";
    pointsSection.appendChild(pointsList);

    // Function to update points list
    function updatePointsList() {
        pointsList.innerHTML = "";

        lightRay.options.lightPoints.forEach((point, index) => {
            const pointItem = document.createElement("div");
            pointItem.className = "point-item";

            const pointInfo = document.createElement("span");
            pointInfo.textContent = `Point ${index + 1}: x=${Math.round(point.x * 100)}%, y=${Math.round(point.y * 100)}%`;

            const deleteButton = document.createElement("button");
            deleteButton.textContent = "×";
            deleteButton.className = "delete-button";
            deleteButton.addEventListener("click", () => {
                lightRay.removeLightPoint(index);
                updatePointsList();
            });

            pointItem.appendChild(pointInfo);
            pointItem.appendChild(deleteButton);
            pointsList.appendChild(pointItem);
        });
    }

    // Add a point when clicking on canvas
    lightRay.canvas.addEventListener("click", (event) => {
        const rect = lightRay.canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = (event.clientY - rect.top) / rect.height;

        lightRay.addLightPoint(x, y);
        updatePointsList();
    });

    // Button to reset points
    const resetPointsButton = document.createElement("button");
    resetPointsButton.textContent = "Remove All Points";
    resetPointsButton.className = "reset-button";
    resetPointsButton.addEventListener("click", () => {
        lightRay.updateOptions({ lightPoints: [] });
        updatePointsList();
    });

    pointsSection.appendChild(resetPointsButton);
    container.appendChild(pointsSection);
}

// Create a section of controls
function createSection(title, controls, container) {
    const section = document.createElement("div");
    section.className = "control-section";

    const titleElem = document.createElement("h3");
    titleElem.textContent = title.toUpperCase();
    section.appendChild(titleElem);

    controls.forEach(control => {
        const controlElem = document.createElement("div");
        controlElem.className = "control-item";

        const label = document.createElement("label");
        label.textContent = control.label;
        controlElem.appendChild(label);

        if (control.type === "range") {
            const controlWrapper = document.createElement("div");
            controlWrapper.className = "control-wrapper";

            const input = document.createElement("input");
            input.type = "range";
            input.id = control.id;
            input.min = control.min;
            input.max = control.max;
            input.step = control.step;
            input.value = control.value;

            const valueDisplay = document.createElement("span");
            valueDisplay.className = "value-display";
            valueDisplay.textContent = control.value;

            input.addEventListener("input", () => {
                valueDisplay.textContent = Number(input.value).toFixed(2);
                control.onChange(input.value);
            });

            controlWrapper.appendChild(input);
            controlWrapper.appendChild(valueDisplay);
            controlElem.appendChild(controlWrapper);
        } else if (control.type === "color") {
            const input = document.createElement("input");
            input.type = "color";
            input.id = control.id;
            input.value = control.value;

            input.addEventListener("input", () => {
                control.onChange(input.value);
            });

            controlElem.appendChild(input);
        }

        section.appendChild(controlElem);
    });

    container.appendChild(section);
}

// Update control values when changing preset
function updateControlValues(options) {
    // Update sliders
    for (const key in options) {
        if (key === 'lightSource' || key === 'lightPoints') continue;

        const input = document.getElementById(key);
        if (input) {
            input.value = options[key];

            // Update value display for sliders
            if (input.type === "range") {
                const wrapper = input.closest('.control-wrapper');
                if (wrapper) {
                    const display = wrapper.querySelector('.value-display');
                    if (display) {
                        display.textContent = Number(options[key]).toFixed(2);
                    }
                }
            }
        }
    }
}

// Initialize the application
document.addEventListener("DOMContentLoaded", () => {
    // Create main container
    const container = document.createElement("div");
    container.id = "app-container";
    container.style.display = "flex";
    container.style.height = "100vh";
    document.body.appendChild(container);

    // Canvas container
    const canvasContainer = document.createElement("div");
    canvasContainer.id = "canvas-container";
    canvasContainer.style.flex = "1";
    canvasContainer.style.position = "relative";
    canvasContainer.style.overflow = "hidden";

    // Create a checkerboard background to show transparency
    canvasContainer.style.background = `transparent`;
    container.appendChild(canvasContainer);

    // Create canvas
    const canvas = document.createElement("canvas");
    canvas.id = "ray-canvas";
    canvas.style.display = "block";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.imageRendering = "pixelated";
    canvasContainer.appendChild(canvas);

    // Controls container
    const controlsContainer = document.createElement("div");
    controlsContainer.id = "controls-container";
    controlsContainer.style.width = "300px";
    controlsContainer.style.padding = "20px";
    controlsContainer.style.backgroundColor = "#222";
    controlsContainer.style.color = "#fff";
    controlsContainer.style.overflowY = "auto";
    container.appendChild(controlsContainer);

    // Add styles
    const style = document.createElement("style");
    style.textContent = `
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
      }
      
      body {
        background-color: #111;
        color: #eee;
      }
      
      #app-container {
        display: flex;
        height: 100vh;
      }
      
      #canvas-container {
        flex: 1;
        position: relative;
        background-image: 
          linear-gradient(45deg, #333 25%, transparent 25%),
          linear-gradient(-45deg, #333 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #333 75%),
          linear-gradient(-45deg, transparent 75%, #333 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        background-color: #444;
        overflow: hidden;
      }
      
      #ray-canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
        cursor: pointer;
      }
      
      #controls-container {
        width: 300px;
        padding: 20px;
        background-color: #222;
        color: #fff;
        overflow-y: auto;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
      }
      
      .control-section {
        margin-bottom: 20px;
        padding-bottom: 20px;
        border-bottom: 1px solid #444;
      }
      
      h3 {
        margin-bottom: 15px;
        color: #f5d76e;
      }
      
      .control-item {
        margin-bottom: 10px;
      }
      
      label {
        display: block;
        margin-bottom: 5px;
        font-size: 14px;
      }
      
      .control-wrapper {
        display: flex;
        align-items: center;
      }
      
      input[type="range"] {
        flex: 1;
        height: 6px;
        -webkit-appearance: none;
        background: #444;
        outline: none;
        border-radius: 3px;
      }
      
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: #f5d76e;
        border-radius: 50%;
        cursor: pointer;
      }
      
      .value-display {
        width: 40px;
        text-align: right;
        margin-left: 10px;
      }
      
      input[type="color"] {
        width: 40px;
        height: 30px;
        border: none;
        outline: none;
        cursor: pointer;
      }
      
      .presets-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }
      
      .preset-button {
        padding: 8px 12px;
        background-color: #444;
        color: #fff;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .preset-button:hover {
        background-color: #666;
      }
      
      .point-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        margin-bottom: 8px;
        background-color: #333;
        border-radius: 3px;
      }
      
      .delete-button {
        width: 24px;
        height: 24px;
        background-color: #f44336;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      
      .reset-button {
        width: 100%;
        padding: 10px;
        background-color: #f44336;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        margin-top: 10px;
      }
    `;
    document.head.appendChild(style);

    // Create light ray
    const lightRay = new LightRay("ray-canvas", {
        pixelSize: 6,
        angle: 45,
        direction: 270,
        intensity: 1.0,
        centerColor: "#ffffff",
        midColor: "#f5d76e",
        edgeColor: "#996633",
        edgeAlpha: 0.7,
        edgeSharpness: 0.8,
        noise: 0.15,
        density: 0.7,
        brightness: 1.3,
        spread: 0.6,
        minAlpha: 0.05,
        lightPoints: []
    });

    // Create interface
    createInterface("controls-container", lightRay);
});